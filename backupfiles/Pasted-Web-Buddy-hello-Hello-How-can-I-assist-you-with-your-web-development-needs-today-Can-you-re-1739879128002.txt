Web Buddy
hello

Hello! How can I assist you with your web development needs today?

Can you recreate this code and show me a preview<!DOCTYPE html> <html lang="en"> <head>     <meta charset="UTF-8">     <meta name="viewport" content="width=device-width, initial-scale=1.0">     <title>Circuit Particle System</title>     <style>         body {             margin: 0;             padding: 0;             background: #000;             overflow: hidden;             display: flex;             justify-content: center;             align-items: center;             min-height: 100vh;         }          canvas {             position: absolute;         }          #mainCanvas {             z-index: 1;         }     </style> </head> <body>     <canvas id="mainCanvas"></canvas>      <script>         const canvas = document.getElementById('mainCanvas');         const ctx = canvas.getContext('2d');          // Circuit paths configuration         const paths = [];         const circuitPoints = [];         const particles = [];                  let width, height;         const centerX = () => width / 2;         const centerY = () => height / 2;          function resizeCanvas() {             width = window.innerWidth;             height = window.innerHeight;             canvas.width = width;             canvas.height = height;             generateCircuitPaths();         }          class CircuitParticle {             constructor() {                 this.init();             }              init() {                 const pathIndex = Math.floor(Math.random() * paths.length);                 this.path = paths[pathIndex];                 this.progress = 0;                 this.speed = 0.001 + Math.random() * 0.002;                 this.size = 1 + Math.random() * 2;                 this.opacity = 0.3 + Math.random() * 0.5;                 this.direction = Math.random() < 0.5 ? 1 : -1;             }              update() {                 this.progress += this.speed * this.direction;                 if (this.progress > 1 || this.progress < 0) {                     this.init();                 }             }              draw(ctx) {                 const point = this.getCurrentPosition();                 ctx.beginPath();                 ctx.arc(point.x, point.y, this.size, 0, Math.PI * 2);                 ctx.fillStyle = `rgba(0, 255, 255, ${this.opacity})`;                 ctx.fill();             }              getCurrentPosition() {                 const startPoint = this.path[0];                 const endPoint = this.path[1];                 return {                     x: startPoint.x + (endPoint.x - startPoint.x) * this.progress,                     y: startPoint.y + (endPoint.y - startPoint.y) * this.progress                 };             }         }          function generateCircuitPoints() {             const radius = Math.min(width, height) * 0.2;             const innerRadius = radius * 0.6;             const points = [];                          // Generate outer ring points             for (let i = 0; i < 12; i++) {                 const angle = (i / 12) * Math.PI * 2;                 points.push({                     x: centerX() + Math.cos(angle) * radius,                     y: centerY() + Math.sin(angle) * radius                 });             }              // Generate inner ring points             for (let i = 0; i < 8; i++) {                 const angle = (i / 8) * Math.PI * 2;                 points.push({                     x: centerX() + Math.cos(angle) * innerRadius,                     y: centerY() + Math.sin(angle) * innerRadius                 });             }              return points;         }          function generateCircuitPaths() {             paths.length = 0;             const points = generateCircuitPoints();                          // Create circuit connections             for (let i = 0; i < points.length; i++) {                 for (let j = i + 1; j < points.length; j++) {                     if (Math.random() < 0.3) { // 30% chance to create a connection                         paths.push([points[i], points[j]]);                     }                 }             }         }          function initParticles() {             for (let i = 0; i < 100; i++) {                 particles.push(new CircuitParticle());             }         }          function drawCircuitBase() {             const radius = Math.min(width, height) * 0.2;                          // Draw outer circle             ctx.beginPath();             ctx.arc(centerX(), centerY(), radius, 0, Math.PI * 2);             ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)';             ctx.lineWidth = 2;             ctx.stroke();              // Draw inner circle             ctx.beginPath();             ctx.arc(centerX(), centerY(), radius * 0.6, 0, Math.PI * 2);             ctx.stroke();              // Draw circuit paths             paths.forEach(path => {                 ctx.beginPath();                 ctx.moveTo(path[0].x, path[0].y);                 ctx.lineTo(path[1].x, path[1].y);                 ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';                 ctx.lineWidth = 1;                 ctx.stroke();             });              // Draw "AI" text             ctx.font = `${radius * 0.4}px Arial`;             ctx.fillStyle = 'rgba(0, 255, 255, 0.8)';             ctx.textAlign = 'center';             ctx.textBaseline = 'middle';             ctx.fillText('AI', centerX(), centerY());         }          function animate() {             ctx.clearRect(0, 0, width, height);                          drawCircuitBase();                          particles.forEach(particle => {                 particle.update();                 particle.draw(ctx);             });              requestAnimationFrame(animate);         }          // Initialize         window.addEventListener('resize', resizeCanvas);         resizeCanvas();         initParticles();         animate();     </script> </body> </html> 